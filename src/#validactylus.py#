import logging
import argparse
import jsonschema
import requests
import json
import urllib.parse
import referencing # for in-memory registration of schemas
import pandas as pd

logger = logging.getLogger(__name__)

def get_schema_jsons(r_topic, r_shared):
    '''extract schema jsons from server response'''
    return {"topic" : r_topic.json(), "shared" : r_shared.json()}

def register_schemas(r_topic, r_shared):
    '''registers schemas locally
    Using a Registry object to make both the schema_shared and schema_topic
    known locally, references from schema_topic to schema_shared can be
    resolved.
    -- args: r_topic, r_shared: server responses from the remote schemas' host
    '''

    jsons = get_schema_jsons(r_topic, r_shared)

    schema_topic_resource = referencing.Resource(contents = jsons["topic"],
                                                 specification = spec)
    schema_shared_resource = referencing.Resource(contents = jsons["shared"],
                                                  specification = spec)

    return referencing.Registry().with_resources([
        ("https://example.com/data_mapping", schema_topic_resource),
        ("https://example.com/shared", schema_shared_resource)
    ])

def get_instance_from_csv(csv_url):
    '''reads CSV data from a URL, takes header from first and exemplary data
    from second line, converts to JSON-able dictionnairy.
    Example: {"SITE_CODE" : "foo-bar-baz", ...}
    '''
    try:
        instance = (pd.read_csv(csv_url, sep = ";").head(1)
                    .to_json(orient = "records"))
        instance = json.loads(instance)[0] ## first entry of json array only
    except:
        instance = False
    finally:
        return instance

def the_hugo():
    return("the hugo!")

def get_remote_schemas(schema_base_url, name_topic, name_shared):
    '''
    retrieve validation schemas (1. topic specific and 2. shared definitions)
    from host; raise error if not both schemas can be retrieved
    (i. e. if server status not 200 for either schema)
    '''
    logger.info('Doing very something')

    try:
        request.get(schema_base_url)
    except (requests.exceptions.RequestException) as e:
        raise ValueError(f"cannot connect to \"{schema_base_url}\"")

    max_waiting = 5 ## s
    r_topic = requests.get(f"{schema_base_url}{name_topic}.json",
                           timeout = max_waiting)
    r_shared = requests.get(f"{schema_base_url}{'name_shared'}.json",
                            timeout =max_waiting)
    return({r_topic, r_shared})



if __name__ == "__main__":

    ## get centrally managed schemas here:
    schema_base_url = ("https://raw.githubusercontent.com/eLTER-RI/"
                       "elter-ci-schemas/main/schemas/")
    ## use JSONSchema version DRAFT202012:
    spec = referencing.jsonschema.DRAFT202012


    ## currently (Apr. 2024) available topic schemas:
    ## ['data_mapping', 'data_observation', 'event', 'license', 'mapping', 
    ## 'method', 'reference', 'sample', 'station']


    parser = argparse.ArgumentParser()
    parser.add_argument("url_instance", type = str,
                        help = ("URL (file or remote) to CSV instance"
                                "to be validated")
                        )
    parser.add_argument("name_topic", type = str,
                        help = "name of a topic-specific schema")
    parser.add_argument("name_shared", type = str,
                        help = ("name of a schema with definitions shared by"
                                " topic schemas ['shared']"))

    args = vars(parser.parse_args()) ## vars converts result to dictionnary

    ## sanitize path arguments
    ## (only the name, e. g. "data_mapping" should be supplied, but anyway:
    args = {k: urllib.parse.quote(v, safe = ":./_-") for k,v in args.items()}

    if r_topic.status_code != 200:
        raise ValueError(f"Couldn't retrieve schema {args['name_topic']} " +\
                         f"from {schema_base_url}{args['name_topic']}.json")
    if r_shared.status_code != 200:
        raise ValueError(f"Couldn't retrieve schema {args['name_shared']} " +\
                         f"from {schema_base_url}{args['name_shared']}.json")


    instance = get_instance_from_csv(args['url_instance'])

    if any(r.status_code != 200 for r in (r_topic, r_shared)):
        raise ValueError("could not fetch all required schemas from : " +\
                         f"\"{schema_base_url}{args['name_topic']}.json\", " +\
                         f"\"{schema_base_url}{args['name_shared']}.json\"")


    assert instance, f"Instance could not be read from {args['url_instance']}"

    registry = register_schemas(r_topic, r_shared)
    ## create a validator which uses a schema defined in the registry;
    ## this validator then accepts an instance to validate
    v = jsonschema.Draft202012Validator(
        schema = get_schema_jsons(r_topic, r_shared)["topic"],
        registry = registry
    )


    print(json.dumps([{"path" : ','.join(e.path), "message" : e.message}
                      for e in v.iter_errors(instance = instance)
                      ])
          )




